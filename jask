#! /usr/bin/env v8cgi

/*
Jask: Javascript Tasks
	Simple JS Tasks using V8CGI.

License:
	MIT-Style License (See included README file for details).

Copyright:
	Copyright 2009 Mark Obcena, <http://keetology.com>
*/

(function(){

var verbose = false, quiet = false, timers = {};

this.console = {

	log: function(){
		args = Array.prototype.slice.call(arguments);
		if (verbose) args.unshift("  ");
		if (!quiet) system.stdout.call(this, args.join(' ') + '\n');
		return this;
	},

	_log: function(){
		args = Array.prototype.slice.call(arguments); args.unshift("->");
		if (!quiet) system.stdout.call(this, args.join(' ') + '\n');
		return this;
	},

	dir: function(){
		args = Array.prototype.slice.call(arguments);
		for (var i = args.reverse().length; i--;) {
			var x = JSON.stringify(args[i]);
			if (x) this.log(x);
		}
		return this;
	},

	time: function(name){
		timers[name] = new Date().getTime();
		return this;
	},

	timeEnd: function(name){
		var delta = new Date().getTime() - timers[name];
		this._log(name + ": " + delta + "ms.");
		return this;
	}
};

try {

	include('getopt');

	var nscount = 0, nslast = "";

	this.Jask = {

		Tasks: {},
		Args: [],
		Descs: {},

		cwd: system.getcwd() + "/",

		initialize: function(){
			Jask.Tasks = this.Tasks;
			var opts = new GetOpt();
			opts.add('list', 'List all available tasks.', false, 'l', 'list', GetOpt.NO_ARGUMENT);
			opts.add('taskfile', 'The tasksfile to use.', 'taskfile', 't', 'taskfile', GetOpt.REQUIRED_ARGUMENT);
			opts.add('quiet', 'Hide all output messages.', false, 'q', 'quiet', GetOpt.NO_ARGUMENT);
			opts.add('verbose', 'Display verbose messages.', false, 'v', 'verbose', GetOpt.NO_ARGUMENT);
			opts.add('help', 'Show help text.', false, 'h', 'help', GetOpt.NO_ARGUMENT);
			if (arguments.length > 0) {
				opts.parse.apply(opts, arguments);
				if (opts.get('help')) return this.help();
				var taskfile = new File(this.cwd + opts.get('taskfile'));
				if (!taskfile.isFile()) {
					return console.log('\nNo taskfile found! Use --help for more details.\n');
				} else {
					this.parseTasksFile(taskfile.toString());
					if (opts.get('list')) return this.listTasks();
					if (opts.get('quiet')) quiet = true;
					if (opts.get('verbose')) verbose = true;
					var task_args = opts.get();
					if (task_args.length !== 0) {
						var metargs = task_args.shift().split(':');
						var nspace = (metargs.length == 1 && nscount == 1) ? nslast : metargs[0];
						var action = (metargs.length == 1 && nscount == 1) ? metargs[0] : metargs[1] || '_';
						if (this.Tasks[nspace]  && this.Tasks[nspace][action] && action.charAt(0) !== '_') {
							Jask.Args = task_args;
							if (verbose) console.time('Jask Done; Time')._log('Starting Tasks..');
							this.Tasks[nspace][action].apply(this.Tasks[nspace], task_args);
							if (verbose) console.timeEnd('Jask Done; Time');
							return;
						} else {
							return console.log('No such task!\
												\n(Use --help for more details or --list to see available tasks.)\n');
						}
					}
				}
			}
			return this.help();
		},

		parseTasksFile: function(taskfile){
				taskfile = include(taskfile);
				for (var namespace in taskfile) {
					var tasklist = this.Tasks[namespace] = {};
					for (var item in taskfile[namespace]) {
						if (item == 'Include') {
							var includes = taskfile[namespace][item];
							for (var x = 0, y = includes.length; x < y; x++) {
								this.parseTasksFile(this.cwd + includes[x]);
							}
						} else if (item == 'Desc') {
							this.Descs[namespace] = taskfile[namespace][item];
						} else {
							this.parseTask(item, namespace, taskfile[namespace][item]);
						}
					}
					nscount++; nslast = namespace;
				}
		},

		parseTask: function(item, nspace, func){
			var parseName = item.match(/([\d\D]+)[\s]([>|<])[\s]([\d\D]+)/);
			if (parseName) {
				item = parseName[1];
				var condition = parseName[2];
				var p = parseName[3].split(':');
				var oitem = (p.length == 1) ? p[0] : p[1];
				var onspa = (p.length > 1) ? p[0] : nspace;
				var funn = null;
				if (condition == '<') {
					funn = function(){
						args = Array.prototype.slice.apply(arguments);
						console.log(onspa, oitem);
						Jask.Tasks[onspa][oitem].apply(Jask.Tasks[onspa], args);
						func.apply(Jask.Tasks[nspace], args);
					};
				} else {
					funn = function(){
						args = Array.prototype.slice.apply(arguments);
						func.apply(Jask.Tasks[nspace], args);
						Jask.Tasks[onspa][oitem].apply(Jask.Tasks[onspa], args);
					};
				}
			}
			this.Tasks[nspace][item] = function(){
				if (verbose) console._log(['Start task ', nspace,':', item].join(''));
				args = Array.prototype.slice.apply(arguments);
				(funn || func).apply(this, args);
				if (verbose) console._log(['End task ', nspace,':', item].join(''));
			};
		},

		listTasks: function(){
			var buff = "\nAvailable Tasks:\n\n";
			for (var ns in this.Tasks) {
				for (var item in this.Tasks[ns]){
					if (this.Descs[ns] && this.Descs[ns][item]){
						var itemargs = this.Descs[ns][item][1] || "";
						var itemdesc = this.Descs[ns][item][0];
						buff += "  " + ns + ":" + item + " ["  + itemargs + "]\t" + itemdesc + "\n";
					} else if (item.charAt(0) !== '_') {
						buff += "  " + ns + ":" + item + "\n";
					}
				}
			}
			console.log(buff);
			return null;
		},

		help: function(){
			var buff = "JASK: Javascript Tasks\n\nUsage:\n";
			buff += "  $ jask [-t=taskfile] [namespace:]task args\n";
			buff += "  $ jask -l\n\nOptions:\n";
			buff += "  -l, --list\t\t\t\tList available tasks\n";
			buff += "  -t=file, --taskfile=file\t\tSet taskfile.\n";
			buff += "  -q, --quiet\t\t\t\tDon't show any log messages.\n";
			buff += "  -v, --verbose\t\t\t\tShow verbose logs.\n";
			buff += "  -h, --help\t\t\t\tShow this help text.\n";
			console.log(buff);
			return null;
		}

	};

	Jask.Args = [];
	Jask.Tasks = {};

	system.args.shift();
	Jask.initialize(system.args);

} catch(e) {
	console.log(e);
}

})();